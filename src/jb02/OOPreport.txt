1. OOP(Object Oriented Programming)
	C언어를 절차 지향 프로그래밍이라 하는데, 절차 지향 프로그래밍은 프로세스가 함수 단위로 순서대로 진행되는 것.
	
	객체지향프로그래밍이란 현실세계를 온라인화하는 방법론이며 현재 및 미래의 프로그래밍 언어의 방향이며
	모든 것을 객체로 추상화해서 생각하며 각 객체간의 메세지를 통해서 결과를 처리하는 방식이다.
	상속이나 캡슐화, 추상화 개념을 중심으로 발전된 규칙들을 이용하여 코드 간에 서로 관계를 맺어 줌으로써 
	보다 유기적으로 프로그램을 구성한다.
	즉, 애플리케이션을 구성하는 요소들을 객체로 바라보고, 객체들을 유기적으로 연결하여 프로그래밍 하는것
	
	이런 방식으로 프로그래밍을 하면, 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있으며,
	코드간의 관계를 이용해서 적은 노력으로 유지 및 보수를 할 수 있다.
	또한 캡슐화를 이용하여 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지 할 수 있다.
	
	요약하자면 기존의 코드를 이용하여 새로운 코드를 작성할 수 있어 코드의 재사용성이 높고,
	코드간의 관계를 맺어줌으로써 적은 노력으로 코드의 관리가 용이하며, 제어자와 메서드를 이용 데이터를 보호하고 올바른 값이 유지하도록 하며
	코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있기 때문에 신뢰성이 높은 프로그래밍이 가능하다.
	
	강의 후 내생각 : 현실세계를 분석/설계 하여 표현하는 방법론
	
2. Object(객체)
	-식별성 + 상태 + 행위로 이루어짐
	식별성 : 같은 상태를 가지더라도 구분할 수 있다. 개수에 제한이 없다.
	상태  : 객체가 가질 수 있는 조건, 항상변화함, 일반적으로 시간, 행위에 의해 변함
	행위  : 객체가 할 수 있는 메세지의 집합
	즉 객체는 속성과 기능의 집합이라고 볼 수 있음
	- 현실세계에 존재하는 물리적, 개념적인 모든 것이 객체
	- 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻함
	
	
	
3. Class(클래스)
	-공통된 특성(속성), 행위, 관계, 의미를 갖는 객체의 모임
	-현실에 존재하는 객체들이 가질수 있는 상태와 행동들에 대해 추상화 하여 시스템상에 소프트웨어적으로 표현한 것
	-class는 application과 bean으로 분류
	application : main 메소드를 실행하는 클래스
	bean        : object modeling, main이 없는 클래스, 현실세계를 표현
	
	객체들을 추상화하여 표현한  묶음
	
	
4. abstraction(추상화)
	추상화는 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념, 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법.
	-공통적인, 일반적인 것들의 상태/행위를 추출하여 묶는 것
	-문제영역에 의존적임
	-객체지향의 추상화를 이용 System을 모델링 할 수 있음
	-하나의 객체를 미완성으로 완료하여, 상속을 통해서 상속받은 클래스에 의해서 완성될 수 있으며,
	상속받는 여러개의 클래스에서 꼭 필요하지만 자손마다 구현방법이 다를 때 클래스를 작성하는데 도움을 줄 목적으로 사용
	
5. Generalization(일반화)/Inheritance(상속)
	-A is a kind of B 관계 성립( 하위는 상위가 사용되는 곳에 사용가능 : 다형성)
	-속성과 행위의 공유
	
	class 설계 시 특정 class를 상속받아 그 class의 Data(변수)와 Method(기능)를 사용하는 것
	타입만 가져가려면 interface 구현
	타입 + 구현(속성,메소드) 까지 하려면 class 상속 사용
	* Generalization : 추출된 class 들의 공통적인 특성을 모아 super class로 정의할 수 있다.
	
	선택적 상속 불가능 / All or Not만 가능
	- 상속되는 클래스의 속성이나 기능을 선택적으로 상속받을 수 없다. 전부 다 받거나, 아예 안받거나 둘 중 하나만 가능하다.
	- 상속을 받게 되면 super클래스의 모든 속성과 기능을 상속받아 사용 할 수 있다.
	1) 생성자는 상속되지 않는다.
	2) super 클래스에서 private으로 정의된 member 변수는 상속은 가능하지만, 접근은 불가능하다. => 그래서 public으로 선언한 setter 또는 getter를 이용한다.
	- 상속받은 기능 중 수정을 원하는 기능은 다시 재정의 할 수 있고(Overriding), 필요한 속성이나 기능은 추가하여 작성할 수 있다. 객체 생성의 경우에는 재사용만 가능하고 변경, 추가는 불가능하다.
	 
	단일 상속만 가능 (Single Inheritance)
	-다중 상속의 경우 이런 단점이 있다.
	1) 여러 조상들 중에서 이름이 같은 함수가 있을 경우, 문제의 소지가 있음.
	==> 자바는 시스템에 문제가 생길 가능성을 아예 남겨두지 않으려고 하기 때문에 지원하지 않는다.
	2) 너무 무거움. 필요 없는 부분까지 받아야 한다.
	- 그러나 다중 상속의 장점 또한 많기 때문에, 자바는 interface 다중 구현을 제공한다.
	
	생성자는 상속되지 않는다
	-왜 상속되지 않을까? ==> 생성자는 반드시 클래스 이름과 동일하게 써야 하는데, 상속하면 클래스 이름이 달라지므로
	클래스 이름과 동일하게 사용할 수 없어진다.
	- 그러나 재사용을 하기 위해서 호출은 가능하다(상속되는게 아니라 호출만 되는 것, super(a,b,c)이런 식임). 이때 반드시 첫 줄에서만 가능하다.
	
6. Specialization(구체적)
	-추상화 상태를 상속을 통하여 좀 더 구체적인 형태로 발전시키는 과정을 뜻함
	-비슷한 속성과 기능을 가지고 있는 다른 class를 상속 받아 새로운 class를 정의 할 수 있다.
	
7. Realization(실체화)
	- 추상화형태의 객체(인터페이스)를 상속하여 자신이 사용하고자 하는 구현방법에 맞게 오버라이딩 하여
	내용을 완성되어진 것을 의미
	- 부모클래스의 은닉화 선언된 필드 또는 메소드는 상속되지만 접근은 불가능
	- 부모 인스턴스 생성 후 자식 인스턴스 생성
	
8. Association(연관성)
	-has a관계 a->b 계속 가지고 다니는 관계
	-예를 들어 사람을 객체화할 때 팔과 다리라는 객체를 갖고있는 것
	
	
	
9. dependency(의존성)
	-한번 사용하고 버리는 관계 A------->b
	-필요할때 인스턴스를 생성하여 사용 
	-예를 들어 사람을 객체화 하였을 때 야구를 할때만 배트 객체를 생성하여 사용하고 버리는 것
	
10. Polymorphism(다형성)
	-하나의 인터페이스 다양한 활용
	-동일한 인터페이스를 사용할 수 있도록 한다.
	-구현언어(method overloading / overriding / 상위 class가 사용되는 곳에서는 하위 class가 사용 될 수 있다.)
	-한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현
	-메소드(함수) 다중 정의와 메소드 재정의를 제공
	-조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함
	-레퍼런스 형변환 에서는 개념적인 크기로 묵시적형변환이 일어난다.
	-동물 a = new 사람(); 쌉가능
	-사람 b = new 동물(); 나쁜소리들어 // 동물이 조상/부모 클래스야 
	-동물 부모(조상) 사람 자식
	-다형성 마우스 회사 몰라도 마우스 쓰는법 알자나 
	-다형성 알려면 레퍼런스 형변환의 개념 이해 잘해봐 리얼월드에서 이미 우린 익숙해져 있어
	-카피받아온다음 수정했는데 수정한걸 다시 카피한거에 맞추면 당연히 충돌일어나지 !

10.1 overloading : 다형성으로 동일한 메소드를 재활용하는 것 
	 
11. Encapuslation (캡슐화)/ 정차은익/ 정보은익
	자바에서 접근 제어자(public, protrcted 등)가 있다
	private 으로 정의된 속성은 외부에 노출 시키지 않고 자신의 클래스에서만 사용하기 위해 정의한다.
	즉,정보 은닉을 할 수 있다는 특징이 있다.
	-공개적인 interface두로 구현을 숨긴다.
	-구현을 숨기는 절차 은익(client(사용자)에게는 사용방법만 open한다.)
	-객체의 정보를 숨기는 information hiding(객체의 중요한 정보는 open하지 않는다.)
	-ex) get~~()메소드
	
12. constructor 
	객체는 태어날때 부터 서로 다른 상태값을 갖는다 = 초기화
	constructor method overloading 기술을 사용
	
13. javap (class file name) class에 상태/내용을 확인하는 방법.
	
	object / instance
	object 무한대 필드 메소드
	
14. 레퍼런스(String... 등)는 모든 초기화 값/ 기본값 이 null이다.

15. super()/this()
	constructor method o/l 에서 공유(extends)라는 개념을 지원하기위해 keyword
	
16.지역변수 / 전역변수
class 안에있는 변수 전역변수
{}안에 있는 변수 지역변수
	
17.public, (default), protected, private

public 공용화장실	-class
접근제어자가 public으로 설정되었다면 public 접근제어자가 붙은 변수, 메소드는 어떤 클래스에서라도 접근이 가능하다.

default			-class
접근 제어자를 별도로 설정하지 않는다면 접근 제어자가 없는 변수, 메소드는 default 접근 제어자가 되어 해당 패키지 내에서만 접근이 가능하다.

private 안방화장실 -field,method
접근제어자가 private으로 설정되었다면 private 이 붙은 변수, 메소드는 해당 클래스에서만 접근이 가능하다.

protected		-field,method
접근제어자가 protected로 설정되었다면 protected가 붙은 변수, 메소드는 동일 패키지의 클래스 또는 해당 클래스를 상속받은 다른 패키지의 클래스에서만 접근이 가능하다.

private-> default-> protected -> public

18. has a association
Association: 모든 오브젝트가 각자의 라이프사이클을 가지고 있고,
 어떤 오브젝트가 다른 오브젝트를 소유하지는 않은 경우입니다.

예를 들면, 선생님과 학생의 경우를 들 수 있습니다.
 많은 학생이 한 선생님에게 Association를 가질 수 있고,
 한 학생이 여러 선생님에게 Association를 가질 수도 있습니다.
 하지만 이 관계에는 누가 누구를 소유하거나 하지는 않습니다.
 각자가 생성/소멸을 독립적으로 합니다.

20. static, final, abstract (특별한기능)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	